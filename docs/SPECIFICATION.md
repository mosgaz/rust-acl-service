# Техническое задание v.1.0
## Сервис авторизации (Access Control List)

## Статус актуализации (2026-02-20)

Вот финальная версия ТЗ с добавленным блоком "Термины и определения":

---

# Техническое задание: Сервис авторизации (ACL)

## Термины и определения

| Термин | Определение |
|--------|-------------|
| **ACL (Access Control List)** | Список управления доступом — механизм, определяющий права доступа субъектов к объектам. |
| **Субъект (Actor)** | Пользователь, сервисный аккаунт или иной участник, запрашивающий доступ к ресурсу. Идентифицируется UUID. |
| **Объект/Ресурс (Resource)** | Цель запроса доступа — документ, API-эндпоинт, сервис и т.д. Идентифицируется строкой в формате `<тип>:<id>`. |
| **Действие (Action)** | Операция, которую субъект хочет выполнить над ресурсом (например, `create`, `read`, `update`, `delete`). |
| **Разрешение (Permission)** | Связка действия и ресурса в формате `<действие>:<ресурс>` (например, `delete:document`). |
| **Роль (Role)** | Именованный набор разрешений (например, `admin`, `editor`, `viewer`). |
| **Назначение роли (Role Assignment)** | Привязка роли к субъекту. |
| **Назначение разрешения (Permission Assignment)** | Привязка разрешения к роли. |
| **Контекст выполнения (Context)** | Опциональный набор пар ключ-значение, передаваемый в Check API для поддержки динамических политик (ABAC). Содержит дополнительную информацию о запросе (например, IP-адрес, временные метки, атрибуты тенанта). |
| **Политика (Policy)** | Правило, определяющее, при каких условиях субъект может выполнить действие над ресурсом. Внутреннее представление сервиса. |
| **Пространство имен (Namespace)** | Опциональный изолированный набор политик, позволяющий разделять конфигурации доступа для разных доменов или окружений. |
| **Check API** | Интерфейс для проверки прав доступа. Основной метод взаимодействия потребителей с сервисом. |
| **Admin API** | Интерфейс для управления ролями, разрешениями и их назначениями. |
| **Per-request кэш** | Кэш результатов проверки, живущий только в рамках одного запроса потребителя. Очищается после завершения обработки запроса. |
| **Fail closed / Fail open** | Режимы поведения при недоступности сервиса авторизации: `fail closed` — запрещать доступ по умолчанию, `fail open` — разрешать. |
| **RBAC (Role-Based Access Control)** | Модель управления доступом на основе ролей. Доступ определяется ролями, назначенными субъекту. |
| **ABAC (Attribute-Based Access Control)** | Модель управления доступом на основе атрибутов. Доступ определяется атрибутами субъекта, ресурса и окружения. |
| **HRBAC (Hierarchical RBAC)** | Расширение RBAC с поддержкой иерархии ролей (наследование прав). |
| **Тенантность (Multi-tenancy)** | Способность системы обслуживать несколько изолированных групп пользователей (тенантов). Реализуется через resource naming или context, не является встроенной концепцией сервиса. |

## 1. Цель и назначение
Разработать микросервис для централизованного управления доступом (Authorization), обеспечивающий:
- Проверку прав доступа субъектов (пользователей/сервисов) к объектам.
- Гибкую ролевую модель (RBAC с возможностью расширения до ABAC).
- **Абстрагирование от контекста выполнения**: сервис оперирует только идентификаторами и не зависит от бизнес-логики системы (тенантность, домены, проекты и т.д. — прерогатива вызывающей стороны).
- Инкапсуляцию логики авторизации: потребители (сервисы) не зависят от внутренней реализации ACL.

Сервис не занимается аутентификацией (не хранит пароли, не выпускает JWT). Он работает с идентификаторами субъектов, полученными от сервиса аутентификации.

## 2. Функциональные требования

### 2.1. Управление политиками доступа (RBAC)
Сервис должен поддерживать:
- **Субъекты:** пользователи, сервисные аккаунты (идентификаторы в UUID).
- **Роли:** именованные наборы прав.
- **Разрешения (Permissions):** действия над ресурсами в формате `<действие>:<ресурс>` (например, `create:document`, `delete:document`).
- **Контекст выполнения** — опциональный параметр в формате ключ-значение, позволяющий вызывающей стороне передавать дополнительный контекст (например, `{"tenant": "acme", "project": "xyz"}`) для принятия решений.
- **Привязка ролей:** назначение ролей субъектам (user-role assignments).
- **Привязка разрешений:** назначение разрешений ролям (role-permission assignments).
- **Пространства имен (namespaces):** опциональная возможность изоляции наборов политик для разных окружений или доменов.

> **Важно**: Сервис НЕ имеет встроенного понятия "тенант", "домен", "организация" и т.п. Если требуется мультиарендность, она реализуется через:
> - Включение tenant_id в resource (например, `tenant:acme:document:123`)
> - Передачу tenant_id в контексте выполнения
> - Использование пространств имен для изоляции политик

### 2.2. Проверка прав (Check API)
Единый интерфейс проверки:
```
check(
  actor_id: UUID, 
  action: String, 
  resource: String, 
  context: Option<HashMap<String, String>>
) -> bool
```
- **actor_id** — идентификатор субъекта (из AuthN сервиса).
- **action** — действие (например, `"delete"`).
- **resource** — идентификатор ресурса в формате `<тип>:<id>` (например, `"document:456"`).
- **context** — опциональный контекст выполнения (ключ-значение) для поддержки ABAC и динамических политик.
- **Возврат:** `true` — разрешено, `false` — запрещено.

### 2.3. Управление данными (Admin API)
CRUD операции для:
- Создания/удаления ролей.
- Назначения/отзыва ролей у пользователей.
- Назначения/отзыва разрешений для ролей.
- Просмотра прав пользователя.
- **Опционально:** создание/удаление пространств имен для изолированных наборов политик.

### 2.4. Аудит (логирование)
Логировать все значимые события:
- Изменения в ролях/разрешениях.
- Изменения в назначениях ролей.
- Критические ошибки доступа.

## 3. Нефункциональные требования

### 3.1. Инкапсуляция и независимость реализации (ключевой пункт)
- Потребители взаимодействуют с ACL только через API (Check/Admin) — внутренняя реализация скрыта.
- Смена библиотеки авторизации (например, замена Casbin на OPA) или модели (RBAC → ABAC) не должны требовать изменений в сервисах-потребителях.
- Версионирование API (v1, v2) для обратной совместимости.
- **Контекст выполнения** передается как непрозрачный для сервиса набор пар ключ-значение — сервис не интерпретирует его семантику.

### 3.2. Производительность
- **Время ответа Check API:** < 10 мс (p95) при прямом вызове.
- **Пропускная способность:** не менее 10 000 RPS на один инстанс.
- **Кэширование:**
  - In-memory кэш на стороне сервиса для политик.
  - Клиентский per-request кэш результатов проверки.
  - Опционально: Redis для распределенного кэширования.

### 3.3. Надёжность
- Отказоустойчивость: горизонтальное масштабирование, кластеризация.
- Graceful degradation: при недоступности ACL сервиса клиентская библиотека должна возвращать "deny" по умолчанию (fail closed) или "allow" (fail open) в зависимости от конфигурации.
- Ретри и таймауты: настраиваемые параметры для клиентов.
- Circuit breaker pattern для защиты от каскадных отказов.

### 3.4. Безопасность
- Все запросы к Admin API должны быть аутентифицированы (mTLS или API-ключи).
- Check API может быть открыт внутри доверенной сети, но рекомендуется mTLS.
- Защита от брутфорса (rate limiting) на Admin API.
- Хранение данных: только идентификаторы и связи, никаких PII (персональных данных).
- Валидация входных данных на всех уровнях.

### 3.5. Наблюдаемость
- Метрики в Prometheus формате:
  - Количество запросов к Check API (всего, успешных, ошибочных).
  - Время ответа (гистограмма) с разбивкой по эндпоинтам.
  - Размер кэша, попадания/промахи (cache hit/miss ratio).
  - Количество активных политик, ролей, назначений.
- Трейсинг (OpenTelemetry) для сквозной трассировки запросов.
- Логи в структурированном формате (JSON) с корреляционными ID.
- Health check и liveness/readiness probes.

## 4. Технологический стек (предлагаемый)

### 4.1. Бэкенд (сервис)
- **Язык:** Rust (edition 2021)
- **Веб-фреймворк:** Axum или Actix-web
- **Авторизационное ядро:** Casbin (с поддержкой ABAC через context)
- **База данных:**
  - PostgreSQL (основное хранилище) с миграциями через SQLx
  - Redis (опционально, для распределенного кэширования)
- **API:**
  - gRPC (основной, с Tonic) для высокопроизводительных внутренних вызовов
  - REST (для совместимости и упрощения интеграции)
- **Конфигурация:** управление через переменные окружения + конфиг-файлы

### 4.2. Клиентская библиотека (Rust crate)
- Название: `acl-client`
- Функции:
  - Установка соединения с ACL сервисом (поддержка пула соединений)
  - Метод `can(actor_id, action, resource, context)` с автоматическим кэшированием
  - Интеграция с `tower` middleware для Axum/Actix
  - Настраиваемый таймаут и политика повторных попыток
  - Поддержка режимов fail closed/fail open
  - Метрики клиента (hit/miss, ошибки, latency)

## 5. Архитектура взаимодействия

```mermaid
graph TD
    Client[Клиент] -->|JWT + Context| ServiceA[Сервис A]
    
    subgraph "Сервис A"
        AuthN_MW[AuthN Middleware] -->|user_id| AuthZ_Client[ACL Клиент<br/>с per-request кэшем]
        AuthZ_Client -->|check()| BusinessLogic[Бизнес-логика]
        CacheL1[Per-request Cache] --> AuthZ_Client
    end
    
    AuthZ_Client -->|gRPC/REST| ACL_Service[ACL Сервис]
    
    subgraph "ACL Сервис"
        API[Check/Admin API] --> Engine[Authorization Engine]
        Engine --> CacheL2[Policy Cache<br/>(in-memory/Redis)]
        Engine --> DB[(PostgreSQL)]
        
        subgraph "Authorization Engine"
            direction TB
            RBAC[RBAC Model]
            ABAC[ABAC Extensions]
            ContextEval[Context Evaluator]
        end
    end
    
    subgraph "Контекст выполнения"
        Context[tenant_id<br/>ip_address<br/>time<br/>custom_attrs]
    end
    
    Context -.->|передается в check()| AuthZ_Client
```

## 6. Ключевые сценарии использования

### 6.1. Проверка доступа с контекстом
1. Сервис-потребитель получает запрос с JWT и контекстом (например, tenant_id из заголовка).
2. Middleware валидирует JWT, извлекает `user_id`.
3. Бизнес-логика вызывает `acl_client.can(user_id, "delete", "document:123", Some(context))`.
4. Клиент проверяет per-request кэш:
   - Если есть результат — возвращает его.
   - Если нет — отправляет запрос в ACL сервис, кэширует ответ и возвращает.
5. ACL сервис проверяет политики с учетом переданного контекста.
6. Результат логируется и метрики обновляются.

### 6.2. Изоляция данных через resource naming
```
# Примеры именования ресурсов для различных сценариев:

# Тенантность через префикс
document:acme:123              # документ в тенанте acme
document:beta:456               # документ в тенанте beta

# Иерархические ресурсы
folder:123:document:456         # документ в папке 123
project:xyz:task:789             # задача в проекте xyz

# Мультидоменность
service:auth:api:check           # эндпоинт check в сервисе auth
service:billing:api:invoice      # эндпоинт invoice в сервисе billing
```

### 6.3. Администрирование ролей
1. Администратор отправляет запрос на создание роли в определенном пространстве имен.
2. Admin API аутентифицирует запрос (mTLS/API key).
3. Система валидирует входные данные.
4. Транзакционно:
   - Сохраняет новую роль в БД
   - Инвалидирует соответствующий кэш
   - Логирует изменение
5. Возвращает подтверждение создания.

### 6.4. Массовое назначение ролей
1. Импорт списка назначений ролей для множества пользователей.
2. Оптимистичная вставка с проверкой уникальности.
3. Частичный откат при ошибках.
4. Асинхронная инвалидация кэша для затронутых пользователей.

## 7. Критерии готовности (Definition of Done)

### Функциональные критерии
- [ ] Реализован Check API с поддержкой опционального контекста
- [ ] Реализован Admin API для CRUD операций с ролями и разрешениями
- [ ] Реализовано управление назначениями ролей пользователям
- [ ] Поддержка пространств имен (опционально)
- [ ] Все API покрыты контрактными тестами

### Клиентская библиотека
- [ ] Написана клиентская библиотека на Rust с per-request кэшем
- [ ] Реализованы middleware для популярных фреймворков (Axum, Actix)
- [ ] Поддержка fail closed/fail open режимов
- [ ] Интеграция с системой метрик клиента

### Тестирование
- [ ] Модульные тесты покрывают > 80% кода
- [ ] Интеграционные тесты проверяют:
  - Независимость от семантики контекста
  - Возможность реализации тенантности через resource naming/context без изменения сервиса
  - Смену модели авторизации (RBAC ↔ ABAC) без изменения кода потребителей
- [ ] Нагрузочное тестирование подтверждает 10k RPS при p95 < 10ms
- [ ] Тесты отказоустойчивости (circuit breaker, retries, degradation)

### Наблюдаемость
- [ ] Метрики в формате Prometheus интегрированы
- [ ] Структурированные логи (JSON) настроены
- [ ] Трейсинг (OpenTelemetry) реализован
- [ ] Дашборды в Grafana для мониторинга
- [ ] Алерты на критические метрики

### Документация
- [ ] OpenAPI спецификация для REST API
- [ ] gRPC reflection и документация proto-файлов
- [ ] Примеры использования клиентской библиотеки
- [ ] Руководство по развертыванию и конфигурации
- [ ] Описание модели данных и политик

## Комментарии для разработчика

1. **Главный принцип — абстрагирование от бизнес-логики.** Сервис не должен знать, что такое "тенант", "проект" или "организация". Это задачи вызывающей стороны.

2. **Контекст как black box.** Передавайте context как непрозрачный набор ключ-значение. Внутри Casbin он может использоваться в matcher'ах, но сервис не должен валидировать его содержимое.

3. **Именование ресурсов.** Рекомендуйте потребителям использовать иерархические идентификаторы ресурсов для реализации изоляции: `type:tenant:project:resource:id`.

4. **Тестирование абстракции.** В CI добавить тест, который запускает ACL сервис с разными моделями и проверяет, что клиентская библиотека продолжает работать без изменений, передавая один и тот же контекст.

5. **Производительность.**
   - Контекст может быть большим — предусмотрите лимиты на размер (max 16KB).
   - Используйте `bytes` или `Cow` для избежания копирования.
   - Профилируйте критический путь check().

6. **Транзакционность.**
   - Все операции Admin API должны быть транзакционными.
   - Инвалидация кэша должна быть частью транзакции.
   - Рассмотрите паттерн Outbox для критических событий.

7. **Безопасность.**
   - Санитизация всех входных строк.
   - Защита от SQL-инъекций через параметризованные запросы.
   - Rate limiting на всех публичных эндпоинтах.

8. **Graceful degradation.**
   - Клиент должен кэшировать отрицательные результаты (deny) тоже.
   - При недоступности сервиса использовать локальный кэш решений.
   - Реализовать адаптивное увеличение таймаутов при высокой нагрузке.

---

## Приложение A: Примеры использования

### A.1. Базовое использование (Rust)
```rust
use acl_client::{AclClient, Config};

#[tokio::main]
async fn main() {
    let client = AclClient::new(Config {
        endpoint: "http://acl.service:50051".parse()?,
        failover: FailoverPolicy::Closed,
        timeout: Duration::from_millis(100),
        ..Default::default()
    }).await?;
    
    // Простая проверка
    let allowed = client
        .can(user_id, "delete", "document:123", None)
        .await?;
    
    // Проверка с контекстом
    let context = maplit::hashmap! {
        "tenant".to_string() => "acme".to_string(),
        "ip".to_string() => "10.0.0.1".to_string(),
    };
    
    let allowed = client
        .can(user_id, "create", "document:456", Some(context))
        .await?;
}
```

### A.2. Middleware для Axum
```rust
use axum::{Router, routing::get};
use acl_client::axum::AclMiddleware;

let app = Router::new()
    .route("/secure", get(handler))
    .layer(AclMiddleware::new(client, |req| {
        // Извлечение user_id из request extensions
        req.extensions().get::<UserId>().cloned()
    }));
```

### A.3. Пример политики Casbin с контекстом
```conf
# model.conf
[request_definition]
r = sub, obj, act, ctx

[policy_definition]
p = sub, obj, act, eft

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))

[matchers]
m = g(r.sub, p.sub) && keyMatch(r.obj, p.obj) && r.act == p.act && checkContext(r.ctx)
```

```csv
# policy.csv
p, admin, document:* , *, allow
p, editor, document:* , write, allow
p, viewer, document:* , read, allow
p, restricted, document:sensitive, *, deny
```

---

Это финальная версия технического задания с добавленным блоком терминов и определений, уточненной архитектурой и полным набором требований для реализации современного Rust-сервиса авторизации.

5. **Производительность.** Context может быть большим — предусмотрите лимиты на размер и глубокое клонирование только при необходимости.
