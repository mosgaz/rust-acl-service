# Техническое задание: Сервис авторизации (ACL)

## 1. Цель и назначение
Разработать микросервис для централизованного управления доступом (Authorization), обеспечивающий:
- Проверку прав доступа субъектов (пользователей/сервисов) к объектам.
- Гибкую ролевую модель (RBAC с возможностью расширения до ABAC).
- **Абстрагирование от контекста выполнения**: сервис оперирует только идентификаторами и не зависит от бизнес-логики системы (тенантность, домены, проекты и т.д. — прерогатива вызывающей стороны).
- Инкапсуляцию логики авторизации: потребители (сервисы) не зависят от внутренней реализации ACL.

Сервис не занимается аутентификацией (не хранит пароли, не выпускает JWT). Он работает с идентификаторами субъектов, полученными от сервиса аутентификации.

## 2. Функциональные требования

### 2.1. Управление политиками доступа (RBAC)
Сервис должен поддерживать:
- **Субъекты:** пользователи, сервисные аккаунты (идентификаторы в UUID).
- **Роли:** именованные наборы прав.
- **Разрешения (Permissions):** действия над ресурсами в формате `<действие>:<ресурс>` (например, `create:document`, `delete:document`).
- **Контекст выполнения** — опциональный параметр в формате ключ-значение, позволяющий вызывающей стороне передавать дополнительный контекст (например, `{"tenant": "acme", "project": "xyz"}`) для принятия решений.
- **Привязка ролей:** назначение ролей субъектам (user-role assignments).
- **Привязка разрешений:** назначение разрешений ролям (role-permission assignments).

> **Важно**: Сервис НЕ имеет встроенного понятия "тенант", "домен", "организация" и т.п. Если требуется мультиарендность, она реализуется через:
> - Включение tenant_id в resource (например, `tenant:acme:document:123`)
> - Передачу tenant_id в контексте выполнения
> - Создание изолированных наборов политик (опционально, через namespace)

### 2.2. Проверка прав (Check API)
Единый интерфейс проверки:
```
check(actor_id: UUID, action: String, resource: String, context: Option<HashMap<String, String>>) -> bool
```
- **actor_id** — идентификатор субъекта (из AuthN сервиса).
- **action** — действие (например, `"delete"`).
- **resource** — идентификатор ресурса в формате `<тип>:<id>` (например, `"document:456"`).
- **context** — опциональный контекст выполнения (ключ-значение) для поддержки ABAC и динамических политик.
- **Возврат:** `true` — разрешено, `false` — запрещено.

### 2.3. Управление данными (Admin API)
CRUD операции для:
- Создания/удаления ролей.
- Назначения/отзыва ролей у пользователей.
- Назначения/отзыва разрешений для ролей.
- Просмотра прав пользователя.
- **Опционально:** создание изолированных пространств имен (namespaces) для независимых наборов политик.

### 2.4. Аудит (логирование)
Логировать все значимые события:
- Изменения в ролях/разрешениях.
- Критические ошибки доступа.

## 3. Нефункциональные требования

### 3.1. Инкапсуляция и независимость реализации (ключевой пункт)
- Потребители взаимодействуют с ACL только через API (Check/Admin) — внутренняя реализация скрыта.
- Смена библиотеки авторизации (например, замена Casbin на OPA) или модели (RBAC → ABAC) не должны требовать изменений в сервисах-потребителях.
- Версионирование API (v1, v2) для обратной совместимости.
- **Контекст выполнения** передается как непрозрачный для сервиса набор пар ключ-значение — сервис не интерпретирует его семантику.

### 3.2. Производительность
- **Время ответа Check API:** < 10 мс (p95) при прямом вызове.
- **Пропускная способность:** не менее 10 000 RPS на один инстанс.
- **Кэширование:**
  - In-memory кэш на стороне сервиса для политик.
  - Клиентский per-request кэш результатов проверки.

### 3.3. Надёжность
- Отказоустойчивость: горизонтальное масштабирование.
- Graceful degradation: при недоступности ACL сервиса клиентская библиотека должна возвращать "deny" по умолчанию (fail closed) или "allow" (fail open) в зависимости от конфигурации.
- Ретри и таймауты: настраиваемые параметры для клиентов.

### 3.4. Безопасность
- Все запросы к Admin API должны быть аутентифицированы (mTLS или API-ключи).
- Check API может быть открыт внутри доверенной сети, но рекомендуется mTLS.
- Защита от брутфорса (rate limiting) на Admin API.
- Хранение данных: только идентификаторы и связи, никаких PII.

### 3.5. Наблюдаемость
- Метрики в Prometheus формате:
  - Количество запросов к Check API (всего, успешных, ошибочных).
  - Время ответа (гистограмма).
  - Размер кэша, попадания/промахи (cache hit/miss ratio).
- Трейсинг (OpenTelemetry) для сквозной трассировки запросов.
- Логи в структурированном формате (JSON).

## 4. Технологический стек (предлагаемый)

### 4.1. Бэкенд (сервис)
- **Язык:** Rust
- **Веб-фреймворк:** Axum или Actix-web
- **Авторизационное ядро:** Casbin (с поддержкой ABAC через context)
- **База данных:**
  - PostgreSQL (основное хранилище)
  - Redis (опционально, для кэширования)
- **API:** gRPC (основной) + REST (для совместимости)

### 4.2. Клиентская библиотека (Rust crate)
- Название: `acl-client`
- Функции:
  - Установка соединения с ACL сервисом
  - Метод `can(actor_id, action, resource, context)` с автоматическим кэшированием
  - Интеграция с `tower` middleware
  - Настраиваемый таймаут и политика повторных попыток

## 5. Архитектура взаимодейcтвия

```mermaid
graph TD
    Client[Клиент] -->|JWT user_id| ServiceA[Сервис A]
    
    subgraph "Сервис A"
        AuthN_MW[AuthN Middleware] -->|user_id| AuthZ_Client[ACL Клиент<br/>с per-request кэшем]
        AuthZ_Client -->|check()| BusinessLogic[Бизнес-логика]
    end
    
    AuthZ_Client -->|gRPC/REST| ACL_Service[ACL Сервис]
    
    subgraph "ACL Сервис"
        API[Check/Admin API] --> Engine[Authorization Engine]
        Engine --> Cache[Policy Cache]
        Engine --> DB[(PostgreSQL)]
    end
    
    subgraph "Контекст выполнения"
        Context[Tenant ID, Project, etc.] -.->|передается в check()| AuthZ_Client
    end
```

## 6. Ключевые сценарии использования

### 6.1. Проверка доступа с контекстом
1. Сервис-потребитель получает запрос с JWT и контекстом (например, tenant_id из заголовка).
2. Middleware валидирует JWT, извлекает `user_id`.
3. Бизнес-логика вызывает `acl_client.can(user_id, "delete", "document:123", Some(context))`.
4. Клиент проверяет кэш текущего запроса:
   - Если есть результат — возвращает его.
   - Если нет — отправляет запрос в ACL сервис, кэширует ответ и возвращает.
5. ACL сервис проверяет политики с учетом переданного контекста.

### 6.2. Изоляция данных через resource naming
```
# Пример: тенантность через resource
document:acme:123      # документ в тенанте acme
document:beta:456      # документ в тенанте beta

# Пример: иерархические ресурсы
folder:123:document:456
```

### 6.3. Администрирование ролей
1. Администратор отправляет запрос на создание роли.
2. Admin API аутентифицирует запрос.
3. При необходимости указывается namespace для изоляции политик.
4. Система обновляет политики в базе данных.

## 7. Критерии готовности (Definition of Done)

- [ ] Реализован Check API с поддержкой опционального контекста
- [ ] Реализован Admin API для CRUD операций
- [ ] Написана клиентская библиотека с per-request кэшем
- [ ] Контекст выполнения передается без изменений и не интерпретируется сервисом
- [ ] Интеграционные тесты проверяют:
  - Независимость от семантики контекста
  - Возможность реализации тенантности через resource naming/context без изменения сервиса
  - Смену модели авторизации без изменения кода потребителей
- [ ] Нагрузочное тестирование: 10k RPS
- [ ] Метрики и логи интегрированы
- [ ] Документация OpenAPI/gRPC reflection

## Комментарии для разработчика

1. **Главный принцип — абстрагирование от бизнес-логики.** Сервис не должен знать, что такое "тенант", "проект" или "организация". Это задачи вызывающей стороны.

2. **Контекст как black box.** Передавайте context как непрозрачный набор ключ-значение. Внутри Casbin он может использоваться в matcher'ах, но сервис не должен валидировать его содержимое.

3. **Именование ресурсов.** Рекомендуйте потребителям использовать иерархические идентификаторы ресурсов для реализации изоляции: `type:tenant:project:resource:id`.

4. **Тестирование абстракции.** В CI добавить тест, который запускает ACL сервис с разными моделями и проверяет, что клиентская библиотека продолжает работать без изменений, передавая один и тот же контекст.

5. **Производительность.** Context может быть большим — предусмотрите лимиты на размер и глубокое клонирование только при необходимости.
